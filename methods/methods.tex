\section{Introductory thoughts}
To start, a small introduction to ADflow's solvers, its history and the initial
state of SST is given.

In the beginning, this solver was called \textit{Standford University
Multiblock (sumb)}. It was intended as a multiblock solver for turbomachinery.
Later on, it was extended to be used in optimizations. For this, an adjoint
solver was needed. As explained in section \ref{sec:gradient_computation}, the
adjoint method needs partial derivatives which are obtained through means of
finite differences and/or automatic differentiation. For the AD part, a tool
called \textit{tapenade}
\footnote{\url{http://www-tapenade.inria.fr:8080/tapenade/index.jsp}} is used.
It automatically differentiates FORTRAN source code. But to get it working, a
lot of the initial structure had to be changed.




\subsection{Flow Solvers}
ADflow has three different solvers available to solve the RANS equations:
\textit{multigrid (MG)}, \textit{Newton-Krylov (NK)} and \textit{Approximate
Newton-Krylov (ANK)}. It is possible to switch between
the different solvers during a solution run. This allows to use each Solver
when it is most efficient: initiate the simulation using multigrid, once a
certain level of convergence is reached, engage the ANK solver an finally
converge the last couple order of magnitudes using the NK Solver.
\footnote{Please note that the ANK solver by itself is sufficient as a startup
strategy and MG is not necessarily needed.}

Multigrid is the baseline solver that was implemented first. It uses either the
Runge-Kutta (RK), or the Diagonalized Diagonally-Dominant Alternating Direction
Implicit (D3ADI) algorithm as a smoother. The turbulence model is solved in a
decoupled manner and using the Diagonalized Alternating Direction Implicit
(DADI) method.

The Newton-Krylov solver solves the nonlinear system of governing equations by
simply using the Newton's method. To solve this linear system, the GMRES
algorithm is used. The turbulence variables are solved in a coupled manner and
thus no other solvers are needed. This method is equivalent to using Euler's
method with an infinite time step. It is most efficient when the solution is
already at the final stages of convergence. If it is used in the early stages,
it most likely stalls.

The Approximate Newton-Krylov is similar to the NK solver in that it also uses
Euler's method. But its time step is adjustable. At the beginning of the run,
it is quite low and thus increases the stability. This allows it to be used
as a startup strategy where the NK solver wouls most certainly fail. The
lower the residual norm is, the more the time step is increased. And as such, it
approaches Newtons' method. It is subdivided into three different sub-solvers:
\textit{First order ANK (ANK)}, \textit{Second Order ANK (SANK)} and
\textit{Coupled ANK (CANK)}. Please note, the combination of both
\textit{Coupled Second-Order ANK (CSANK)} is also possible.

In its base configuration (ANK) uses a first-order routine for the residual
Jacobian and thus only affects convergence, but not the solution accuracy. Once
a user defined level of convergence is reached, the solver switches to an exact
Jacobian formulation (SANK). In these two stages, the turbulence model is
solved in a decoupled manner. Once can choose between a second
turbulence-only-ANK solver or the above mentioned DADI method. It is done this
way because the turbulence models in RANS simulations are notoriously difficult
to converge. Once again, when the residual norm reaches a user-defied level,
the coupled mode is enganged. In that state, only one ANK solver remains which
solve the flow and turbulence variables simultaneously. This helps to improve
the convergence in the later stages. \cite{adflow_solvers}




\subsection{Adjoint Solver}




\subsection{Initial state of SST}
When sumb was developed initially, a multitude of different turbulence models
were implemented such as Spalart-Allmaras (SA) or SST. When the code was
overhauled for optimization, only the SA model was carried over and
differentiated. At that point SST would throw NaNs\footnote{Not a Number} and
crash. Lately, this was fixed to a point where the DADI turbulence solver would
work \footnote{See pull request:
\url{https://github.com/mdolab/adflow/pull/107}}. To summarize, before this
project started, the code for SST was there and could be solved using ANK/SANK
and the decoupled DADI turbulence solver. But nothing was differentiated which
means, the adjoint, NK and coupled ANK solvers were not usable.








\section{Needed changes}
ADflow can parallelize the computation over multiple cpus and computers. It
does this by splitting up the computational domain into blocks. These blocks
may live on different cpus or computers. As those blocks do not live in
isolation and do depended on each other, adjacent blocks need to exchange
information. ADflow uses the \textit{halo cell} approach for this. The idea is
to have imaginary ghost (halo) cells around each block. Then they are filled
with the values from the adjacent blocks. Figure \ref{fig:halo_cells} shows
this idea. ADflow can employ second order discretizations and thus needs two
layers of halo cells.

\begin{figure}[H] \centering
\includegraphics[width=0.7\textwidth]{halo_cells}
    \caption{A block split in 4 (left) and its corresponding halo cells (right)
            \cite{cfd_halo}.}
    \label{fig:halo_cells}
\end{figure}




\subsection{Halo exchange and AD}
This halo exchange is straight forward when one does not care about automatic
differentiation. But we do, and as such, some things need to be considered. The
exchanges is performed using the \textit{Message Passing Interface (MPI)}.
Unfortunately, tapenade can not handle MPI calls. To make this work, the
differentiated code is divided into parts: The \textbf{math heavy} part is
differentiated using tapenade. The \textbf{remaining part} is
hand-differentiated. This is not a big problem as this part mostly consists of
calling the AD part and performing communication. 

The turbulence model is considered a math heavy part that is automatically
differentiated using tapenade. For SA, this was straight forward as there is no
communication going on. But SST has one special case: The blending function
$\mathbf{F_1}$ (equation \ref{eq:f1}). The problem is, it is not a normal
turbulence working variable (such as $k$ or $\omega$) and thus is not exchanged
using existing infrastructure. The developers of sumb fixed this by exchanging
it manually after computing it. This is done in the model itself and was no
problem because nobody intended to AD it. \\

Now the question is: Why was it done this way and how do we get rid of this
intermediate communication?

The first part of the questions might be explained by fact that sumb was
initially developed in the early 2000's. Back then, computing power was more
expensive and computing the same $F_1$ value on different blocks was
wasteful. The cost of communication was negligible in comparison. This did not
really change, but computing power became a lot cheaper. So if it makes AD
easier, it is a good trade to get rid of the communication.








\section{Changes to wall distance}
We settled on the idea of computing $F_1$ in the halo cells instead of
communicating it across. To do this, we need to take a closer look at $F_1$. It
depends on $arg_1$ (eq. \ref{eq:arg1}) which also depends on $CD_{kw}$ (eq.
\ref{eq:cdkw}). \noindent It is a bit problematic as it requires the
derivatives $\nabla k \nabla \omega$. This means, we need even more halo cells
to compute the halo cells. Luckily, ADflow employs only a first-order
discretization for the turbulence model. Thus, the second layer of halo cells
is enough to compute $CD_{kw}$ in the first halo layer.

On further examination, we realize that $arg_1$ also depends on the distance to
the nearest wall. Unfortunately, in ADflow, the distance to the nearest wall is
not assigned nor exchanged for halo cells . Thus, this needs to be changed.




\subsection{Wall distance computation}
Before explaining the changes, one must briefly understand how the wall
distance computation is done in ADflow. \footnote{The interested reader may
take a look at report \cite{vt1} where it is explained in more detail.} It is
important to realize that this is no easy task due to the block splitting. When
computing the distance to the nearest wall in a cell on processor X, it is
possible that the nearest wall lives on processor Y. 

To make a long story short, ADflow first determines the which surface cell
holds the closets point for the current cell. This information is changed and
not updated anymore. Later, it calls a routine named
\texttt{updateWallDistancesQuickly()}. This then actually computes the distance.
The underlying assumption is, that a deformed mesh does not introduce lateral
movement that would change the outcome of the first determination. 




\subsection{Halo exchange}
Now, we need to quickly talk about the halo exchange routine. For this, ADflow
has two options: \texttt{whalo1(...)} and \texttt{whalo2(...)}. Please note the
arguments were omitted for brevity. But it just takes flags that control what
we want to exchange. E.g it is possible to only exchange the pressure, or the
velocity, or even more together. The only difference between those functions is
that the first only exchanges the halos in the first layer and the second
exchanges all. As wee need both layers, \texttt{whalo2(...)} is modified. This
has been straight forward and is not elaborated further. Please take  a look at
the source code if you are interested in more detail.



\subsection{Bringing it together}
The easy approach would be to simply call \texttt{whalo2(...)} at the end of
\texttt{updateWallDistancesQuickly()}. This is not possible as this function is
AD-ed and tapenade can not handle MPI-calls. So the next obvious choice is to
call \texttt{whalo2(...)} manually every time
\texttt{updateWallDistancesQuickly()} was executed. When initializing, the
distance is computed before the communication part is initialized and thus
crashes. The final solution was that a Boolean flag is introduced:
\texttt{exchangeWallDistanceHalos}. If it is true, the normal halo
exchange-calls perform also the distance exchange. This works fine, but is a bit
of a hack. The author is believes it is possible to get rid of it once he
understands the code even better.








\section{Algorithmic/Automatic Differentiation}





\section{Verification}

\subsection{Testcases}

\subsubsection{NACA 0012}
\subsubsection{RAE 2822}
\subsubsection{Flatplate}
\subsubsection{2D bump}
\subsubsection{3D wing}


\subsection{Partial derivatives}

\subsection{Total derivatives}


